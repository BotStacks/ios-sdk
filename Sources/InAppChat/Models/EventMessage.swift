//
// EventMessage.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public enum EventMessage: Codable, JSONEncodable, Hashable {
    case typeAvailabilityEvent(AvailabilityEvent)
    case typeChatReportEvent(ChatReportEvent)
    case typeGroupUpdateEvent(GroupUpdateEvent)
    case typeMsgReadEvent(MsgReadEvent)
    case typeNewMessageEvent(NewMessageEvent)
    case typeReactionEvent(ReactionEvent)
    case typeTenantUpdateEvent(TenantUpdateEvent)
    case typeTypingEvent(TypingEvent)
    case typeUpdateMessageEvent(UpdateMessageEvent)
    case typeUserSelfUpdateEvent(UserSelfUpdateEvent)

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .typeAvailabilityEvent(let value):
            try container.encode(value)
        case .typeChatReportEvent(let value):
            try container.encode(value)
        case .typeGroupUpdateEvent(let value):
            try container.encode(value)
        case .typeMsgReadEvent(let value):
            try container.encode(value)
        case .typeNewMessageEvent(let value):
            try container.encode(value)
        case .typeReactionEvent(let value):
            try container.encode(value)
        case .typeTenantUpdateEvent(let value):
            try container.encode(value)
        case .typeTypingEvent(let value):
            try container.encode(value)
        case .typeUpdateMessageEvent(let value):
            try container.encode(value)
        case .typeUserSelfUpdateEvent(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(AvailabilityEvent.self) {
            self = .typeAvailabilityEvent(value)
        } else if let value = try? container.decode(ChatReportEvent.self) {
            self = .typeChatReportEvent(value)
        } else if let value = try? container.decode(GroupUpdateEvent.self) {
            self = .typeGroupUpdateEvent(value)
        } else if let value = try? container.decode(MsgReadEvent.self) {
            self = .typeMsgReadEvent(value)
        } else if let value = try? container.decode(NewMessageEvent.self) {
            self = .typeNewMessageEvent(value)
        } else if let value = try? container.decode(ReactionEvent.self) {
            self = .typeReactionEvent(value)
        } else if let value = try? container.decode(TenantUpdateEvent.self) {
            self = .typeTenantUpdateEvent(value)
        } else if let value = try? container.decode(TypingEvent.self) {
            self = .typeTypingEvent(value)
        } else if let value = try? container.decode(UpdateMessageEvent.self) {
            self = .typeUpdateMessageEvent(value)
        } else if let value = try? container.decode(UserSelfUpdateEvent.self) {
            self = .typeUserSelfUpdateEvent(value)
        } else {
            throw DecodingError.typeMismatch(Self.Type.self, .init(codingPath: decoder.codingPath, debugDescription: "Unable to decode instance of EventMessage"))
        }
    }
}

